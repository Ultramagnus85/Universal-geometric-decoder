
import React, { useState, useEffect, useRef } from 'react';
import {
  Play,
  Upload,
  ChevronRight,
  Calculator,
  Eye,
  CheckCircle,
  ImageIcon,
  RotateCcw,
  Zap
} from 'lucide-react';

const SacredGeometryDecoder = () => {
  const [selectedSymbol, setSelectedSymbol] = useState('seedOfLife');
  const [currentStep, setCurrentStep] = useState(0);
  const [isProcessing, setIsProcessing] = useState(false);
  const [uploadedImage, setUploadedImage] = useState(null);
  const [imageAnalysis, setImageAnalysis] = useState(null);
  const [mode, setMode] = useState('preset'); // 'preset' or 'upload'
  const [error, setError] = useState(null);

  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);

  // --- Preset Symbols ---(copied as-is from your code, truncated for brevity)
  const presetSymbols = { /* ... (include your full presetSymbols object here) ... */ };

  // --- Analysis Steps ---
  const pipelineSteps = [
    'Input Symbol Geometry',
    'Extract Constraint Properties',
    'Apply Field Operators',
    'Solve Governing Equation',
    'Verify Physical Validity'
  ];

  // --- Image Analysis Logic (your full function here) ---
  const analyzeGeometricImage = (e, canvas) => {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    if (!ctx || width === 0 || height === 0) {
      setError('Invalid canvas context or dimensions');
      return null;
    }
    const data = ctx.getImageData(0, 0, width, height).data;
    let analysis = {
      name: 'Custom Geometry',
      description: 'Uploaded geometric form',
      geometry: '',
      constraint: '',
      operator: '',
      physicsLaw: '',
      application: '',
      equation: '',
      verification: ''
    };
    let pixelCount = 0;
    let centerX = 0, centerY = 0;
    let minX = width, maxX = 0, minY = height, maxY = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        const r = data[idx];
        const g = data[idx + 1];
        const b = data[idx + 2];
        const brightness = (r + g + b) / 3;
        if (brightness < 200) {
          pixelCount++;
          centerX += x;
          centerY += y;
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }
      }
    }
    if (pixelCount < 100) {
      setError('No significant geometric features detected in the image');
      return null;
    }
    centerX = pixelCount > 0 ? centerX / pixelCount : width / 2;
    centerY = pixelCount > 0 ? centerY / pixelCount : height / 2;
    const aspectRatio = (maxX - minX) / (maxY - minY + 0.0001);
    const fillRatio = pixelCount / (width * height);
    const compactness = pixelCount / ((maxX - minX + 1) * (maxY - minY + 1));
    let radialSymmetry = 0;
    let circularityScore = 0;
    const maxRadius = Math.min(width, height) / 2;
    const angles = 32;
    const radialSamples = [];
    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / angles) {
      let radialPixels = 0;
      for (let r = 0; r < maxRadius; r += 2) {
        const x = Math.round(centerX + r * Math.cos(angle));
        const y = Math.round(centerY + r * Math.sin(angle));
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const idx = (y * width + x) * 4;
          const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
          if (brightness < 200) radialPixels++;
        }
      }
      radialSamples.push(radialPixels);
      circularityScore += radialPixels;
    }
    const meanRadial = radialSamples.reduce((sum, val) => sum + val, 0) / radialSamples.length;
    radialSymmetry = 1 - (radialSamples.reduce((sum, val) => sum + Math.abs(val - meanRadial), 0) / (meanRadial * radialSamples.length));
    if (radialSymmetry > 0.85 && aspectRatio > 0.8 && aspectRatio < 1.2 && compactness > 0.3) {
      analysis.geometry = 'Circular symmetry, high radial consistency';
      analysis.constraint = 'Radial field divergence with central source';
      analysis.operator = '∇ · E = ρ/ε₀';
      analysis.physicsLaw = 'Coulomb Field / Point Source Divergence';
      analysis.application = 'Electric monopole, gravitational point mass, scalar field source';
      analysis.equation = '∇²Φ = -ρ/ε₀ (Poisson equation)';
      analysis.verification = 'Dimensional: [∇²Φ] = [ρ]/[ε₀] ✓';
    } else if (aspectRatio > 2 || aspectRatio < 0.5) {
      analysis.geometry = 'Linear extension, directional anisotropy';
      analysis.constraint = 'Unidirectional field propagation';
      analysis.operator = '∂²u/∂x² = (1/c²)∂²u/∂t²';
      analysis.physicsLaw = 'Wave Equation / Linear Propagation';
      analysis.application = 'Electromagnetic waves, sound waves, vibrating strings';
      analysis.equation = 'u(x,t) = A sin(kx - ωt)';
      analysis.verification = 'Dimensional: [k²u] = [ω²u/c²] ✓';
    } else if (fillRatio < 0.1) {
      analysis.geometry = 'Sparse network topology, discrete nodes';
      analysis.constraint = 'Discrete lattice with nearest-neighbor coupling';
      analysis.operator = 'H|ψ⟩ = E|ψ⟩ with tight-binding model';
      analysis.physicsLaw = 'Quantum Lattice / Tight-Binding Hamiltonian';
      analysis.application = 'Crystal band structure, quantum dots, molecular orbitals';
      analysis.equation = 'E = -2t cos(ka) (1D tight-binding)';
      analysis.verification = 'Dimensional: [E] = [t] (energy units) ✓';
    } else if (compactness < 0.5 && radialSymmetry < 0.7) {
      analysis.geometry = 'Self-similar structure, fractal boundary conditions';
      analysis.constraint = 'Scale-invariant field behavior with fractal dimension';
      analysis.operator = '(-∇²)^(α/2) u = f (fractional Laplacian)';
      analysis.physicsLaw = 'Fractional Diffusion / Anomalous Transport';
      analysis.application = 'Turbulent mixing, porous media flow, biological membranes';
      analysis.equation = '∂u/∂t = D_α (-∇²)^(α/2) u';
      analysis.verification = 'Dimensional: [D_α] = [L^α]/[T] ✓';
    } else {
      analysis.geometry = 'Complex multi-modal structure with mixed symmetries';
      analysis.constraint = 'Superposition of multiple geometric modes';
      analysis.operator = 'Φ(x) = Σ_i c_i φ_i(x) with ∇²φ_i = λ_iφ_i';
      analysis.physicsLaw = 'Eigenmode Decomposition / Spectral Analysis';
      analysis.application = 'Cavity resonances, structural vibrations, quantum confined states';
      analysis.equation = 'λ_i = (nπ/L)² for 1D cavity modes';
      analysis.verification = 'Dimensional: [λ] = [L⁻²] ✓';
    }
    analysis.description = `Analyzed geometric form with aspect ratio ${aspectRatio.toFixed(2)}, fill ratio ${fillRatio.toFixed(3)}, radial symmetry ${radialSymmetry.toFixed(2)}`;
    return analysis;
  };

  // --- Image Upload Handler ---
  const handleImageUpload = (event) => {
    setError(null);
    const file = event.target.files[0];
    if (!file) {
      setError('No file selected');
      return;
    }
    if (!file.type.startsWith('image/')) {
      setError('Please upload a valid image file (PNG, JPG, GIF)');
      return;
    }
    if (file.size > 10 * 1024 * 1024) {
      setError('Image size exceeds 10MB limit');
      return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new window.Image();
      img.onload = () => {
        setUploadedImage(img);
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const maxSize = 400;
        const scale = Math.min(maxSize / img.width, maxSize / img.height);
        canvas.width = img.width * scale;
        canvas.height = img.height * scale;
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        const analysis = analyzeGeometricImage(e, canvas);
        if (analysis) {
          setImageAnalysis(analysis);
          setMode('upload');
        }
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  };

  // --- Analysis Run and Reset ---
  const runAnalysis = () => {
    setIsProcessing(true);
    setCurrentStep(0);
    const interval = setInterval(() => {
      setCurrentStep(prev => {
        if (prev < pipelineSteps.length - 1) {
          return prev + 1;
        } else {
          setIsProcessing(false);
          clearInterval(interval);
          return prev;
        }
      });
    }, 800);
  };

  const resetAnalysis = () => {
    setCurrentStep(0);
    setIsProcessing(false);
    setUploadedImage(null);
    setImageAnalysis(null);
    setError(null);
    setMode('preset');
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const getCurrentSymbol = () => {
    return mode === 'upload' && imageAnalysis ? imageAnalysis : presetSymbols[selectedSymbol];
  };

  const currentSymbol = getCurrentSymbol();

  return (
    <div className="max-w-xl mx-auto p-6 space-y-4 bg-slate-900 text-white rounded-lg shadow-lg">
      <h1 className="text-2xl font-bold">Sacred Geometry Physics Decoder</h1>
      <p className="text-slate-200 mb-2">Decode geometric patterns into fundamental physics equations</p>

      <div>
        <h2 className="font-semibold mb-2">Input Geometry</h2>
        <div className="flex gap-2 mb-4">
          <button
            type="button"
            onClick={() => setMode('preset')}
            className={`px-4 py-2 rounded-lg font-medium transition-colors ${
              mode === 'preset' ? 'bg-blue-500 text-white' : 'bg-white/10 text-blue-200 hover:bg-white/20'
            }`}
          >
            Preset Symbols
          </button>
          <button
            type="button"
            onClick={() => setMode('upload')}
            className={`px-4 py-2 rounded-lg font-medium transition-colors ${
              mode === 'upload' ? 'bg-blue-500 text-white' : 'bg-white/10 text-blue-200 hover:bg-white/20'
            }`}
          >
            Upload Image
          </button>
          <button
            type="button"
            onClick={resetAnalysis}
            className="px-3 py-2 rounded-lg text-blue-200 hover:text-blue-500 inline-flex items-center"
            title="Reset"
          >
            <RotateCcw className="w-4 h-4" />
          </button>
        </div>

        {mode === 'preset' ? (
          <div className="space-y-2">
            {Object.entries(presetSymbols).map(([key, symbol]) => (
              <button
                key={key}
                onClick={() => setSelectedSymbol(key)}
                className={`w-full text-left p-3 rounded-lg transition-colors border ${
                  selectedSymbol === key
                    ? 'bg-blue-500/30 border-blue-400'
                    : 'bg-white/5 hover:bg-white/10 border-white/10'
                }`}
              >
                <div className="font-semibold">{symbol.name}</div>
                <div className="text-blue-100 text-sm">{symbol.description}</div>
              </button>
            ))}
          </div>
        ) : (
          <div className="flex flex-col items-center gap-3">
            <input
              type="file"
              ref={fileInputRef}
              onChange={handleImageUpload}
              accept="image/*"
              hidden
            />
            <button
              type="button"
              onClick={() => fileInputRef.current?.click()}
              className="flex flex-col items-center gap-2 text-blue-200 hover:text-white transition-colors"
            >
              <Upload className="w-6 h-6" />
              <span>{uploadedImage ? 'Change file' : 'Click to upload geometric image'}</span>
            </button>
            {uploadedImage && (
              <canvas
                ref={canvasRef}
                className="border border-gray-700 rounded"
                style={{ maxWidth: 256, maxHeight: 256 }}
              />
            )}
          </div>
        )}
        {error && (
          <div className="mt-2 text-red-400">{error}</div>
        )}
      </div>

      <div>
        <h2 className="font-semibold mt-4 mb-2">Analysis Pipeline</h2>
        <div className="space-y-1">
          {pipelineSteps.map((step, index) => (
            <div key={step} className="flex items-center gap-2">
              {index < currentStep ? (
                <CheckCircle className="w-4 h-4 text-green-400" />
              ) : index === currentStep && isProcessing ? (
                <Zap className="w-4 h-4 text-yellow-400 animate-bounce" />
              ) : (
                <ChevronRight className="w-4 h-4 text-slate-400" />
              )}
              <span>{step}</span>
            </div>
          ))}
        </div>
        <button
          type="button"
          onClick={runAnalysis}
          disabled={isProcessing}
          className={`mt-3 w-full px-4 py-2 rounded-lg text-white font-bold ${
            isProcessing ? 'bg-blue-300/40 cursor-not-allowed' : 'bg-blue-500 hover:bg-blue-700'
          }`}
        >
          {isProcessing ? 'Processing...' : (
            <span className="inline-flex items-center gap-2">
              <Play className="w-4 h-4" /> Run Analysis
            </span>
          )}
        </button>
      </div>

      {currentStep >= pipelineSteps.length - 1 && (
        <div className="border border-blue-900 rounded-lg mt-6 shadow bg-blue-900/10 p-4 space-y-2">
          <h3 className="font-bold text-lg mb-2">Physics Mapping Results</h3>
          <div><span className="font-semibold">Geometric Properties:</span> {currentSymbol.geometry}</div>
          <div><span className="font-semibold">Physical Constraint:</span> {currentSymbol.constraint}</div>
          <div><span className="font-semibold">Mathematical Operator:</span> {currentSymbol.operator}</div>
          <div><span className="font-semibold">Physics Law:</span> {currentSymbol.physicsLaw}</div>
          <div><span className="font-semibold">Physical Applications:</span> {currentSymbol.application}</div>
          <div><span className="font-semibold">Governing Equation:</span> {currentSymbol.equation}</div>
          <div><span className="font-semibold">Dimensional Verification:</span> {currentSymbol.verification}</div>
        </div>
      )}
    </div>
  );
};

export default SacredGeometryDecoder;
