<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ”· Universal Geometric Transcoder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1e3a8a, #1e1b4b);
            color: white;
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(45deg, #60a5fa, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            gap: 10px;
        }

        .mode-btn {
            padding: 10px 20px;
            border: 2px solid transparent;
            border-radius: 8px;
            background: rgba(59, 130, 246, 0.3);
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn.active {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.6);
        }

        .decode-section, .encode-section {
            display: none;
        }

        .decode-section.active, .encode-section.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 30px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            min-width: 140px;
            justify-content: center;
        }

        .btn-upload { background: #2563eb; }
        .btn-decode { background: #16a34a; }
        .btn-encode { background: #ea580c; }
        .btn-copy { background: #7c3aed; }
        .btn-clear { background: #dc2626; }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .image-preview {
            text-align: center;
            margin-bottom: 20px;
        }

        .image-preview img {
            max-width: 300px;
            max-height: 200px;
            border-radius: 8px;
            border: 2px solid #3b82f6;
        }

        .error {
            background: #7f1d1d;
            border: 1px solid #dc2626;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .encode-form {
            background: rgba(30, 58, 138, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #94a3b8;
        }

        .form-group select, .form-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #374151;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 14px;
        }

        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .results {
            background: rgba(30, 58, 138, 0.3);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .step {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .step-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 10px;
        }

        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 10px;
        }

        .data-item {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px;
            border-radius: 6px;
        }

        .data-label {
            font-size: 0.85rem;
            color: #94a3b8;
            text-transform: uppercase;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .data-value {
            font-family: monospace;
            font-size: 0.9rem;
            word-break: break-all;
            margin-bottom: 8px;
        }

        .processing {
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid #60a5fa;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .geometry-canvas {
            text-align: center;
            margin: 20px 0;
        }

        .geometry-canvas canvas {
            border: 2px solid #3b82f6;
            border-radius: 8px;
            background: white;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 600px) {
            .header h1 { font-size: 2rem; }
            .controls { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 280px; }
            .data-grid, .parameter-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ”· Universal Geometric Transcoder</h1>
            <p>5-Step Reversible Methodology â€¢ Decode & Encode</p>
        </div>

        <div class="mode-selector">
            <div class="mode-btn active" onclick="setMode('decode')">ðŸ“¥ DECODE (Image â†’ Data)</div>
            <div class="mode-btn" onclick="setMode('encode')">ðŸ“¤ ENCODE (Data â†’ Geometry)</div>
        </div>

        <div class="decode-section active">
            <div class="controls">
                <button class="btn-upload" onclick="uploadImage()">ðŸ“¤ Upload Image</button>
                <button class="btn-decode" onclick="decodeGeometry()" id="decodeBtn" disabled>âš¡ Decode Geometry</button>
                <button class="btn-copy" onclick="copyResults('decode')" id="copyDecodeBtn" style="display:none">ðŸ“‹ Copy Results</button>
                <button class="btn-clear" onclick="clearAll()">ðŸ”„ Clear All</button>
            </div>
            <div id="imagePreview" class="image-preview" style="display:none"></div>
        </div>

        <div class="encode-section">
            <div class="encode-form">
                <h3 style="margin-bottom: 20px; color: #60a5fa;">Geometric Parameters Input</h3>
                <div class="parameter-grid">
                    <div class="form-group">
                        <label>Pattern Type</label>
                        <select id="patternType" onchange="updatePhysicsMapping()">
                            <option value="radial">Radial (Circular/Spherical)</option>
                            <option value="linear">Linear (Wave/Directional)</option>
                            <option value="network">Network (Lattice/Grid)</option>
                            <option value="fractal">Fractal (Self-Similar)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Symmetry Score (0-1)</label>
                        <input type="number" id="symmetryScore" min="0" max="1" step="0.01" value="0.85">
                    </div>
                    <div class="form-group">
                        <label>Aspect Ratio</label>
                        <input type="number" id="aspectRatio" step="0.01" value="1.0">
                    </div>
                    <div class="form-group">
                        <label>Golden Ratio Deviation</label>
                        <input type="number" id="phiDeviation" step="0.001" value="0.618">
                    </div>
                    <div class="form-group">
                        <label>Fill Density (0-1)</label>
                        <input type="number" id="fillDensity" min="0" max="1" step="0.01" value="0.5">
                    </div>
                    <div class="form-group">
                        <label>Scale Factor</label>
                        <input type="number" id="scaleFactor" step="0.1" value="100">
                    </div>
                </div>
                <div class="controls" style="margin-top: 20px;">
                    <button class="btn-encode" onclick="encodeGeometry()">ðŸŽ¯ Generate Geometry</button>
                    <button class="btn-copy" onclick="copyResults('encode')" id="copyEncodeBtn" style="display:none">ðŸ“‹ Copy Parameters</button>
                </div>
            </div>
            <div id="generatedGeometry" class="geometry-canvas" style="display:none"></div>
        </div>

        <div id="error" class="error" style="display:none"></div>
        <div id="processing" class="processing" style="display:none">
            <div class="spinner"></div>
            <p>Processing geometric patterns...</p>
        </div>
        <div id="results" style="display:none"></div>

        <input type="file" id="fileInput" accept="image/*" style="display:none" onchange="handleFileSelect(event)">
        <canvas id="analysisCanvas" style="display:none"></canvas>
    </div>

    <script>
        let currentAnalysis = null;
        let currentMode = 'decode';

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.mode-btn[onclick="setMode('${mode}')"]`).classList.add('active');
            
            document.querySelectorAll('.decode-section, .encode-section').forEach(section => {
                section.classList.remove('active');
            });
            document.querySelector(`.${mode}-section`).classList.add('active');
            clearAll();
        }

        function uploadImage() {
            document.getElementById('fileInput').click();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                showError('Please upload an image file (JPG, PNG, GIF)');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    showImagePreview(e.target.result);
                    prepareCanvas(img);
                    document.getElementById('decodeBtn').disabled = false;
                    hideError();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function showImagePreview(src) {
            const preview = document.getElementById('imagePreview');
            preview.innerHTML = `<img src="${src}" alt="Uploaded geometry">`;
            preview.style.display = 'block';
        }

        function prepareCanvas(img) {
            const canvas = document.getElementById('analysisCanvas');
            const ctx = canvas.getContext('2d');
            
            const maxSize = 300;
            const scale = Math.min(maxSize / img.width, maxSize / img.height);
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        }

        async function decodeGeometry() {
            const canvas = document.getElementById('analysisCanvas');
            if (!canvas.width) {
                showError('Please upload an image first');
                return;
            }

            document.getElementById('processing').style.display = 'block';
            document.getElementById('results').style.display = 'none';
            hideError();

            await new Promise(resolve => setTimeout(resolve, 2000));

            const analysis = analyzeCanvas(canvas);
            if (analysis) {
                currentAnalysis = analysis;
                displayResults(analysis);
                document.getElementById('copyDecodeBtn').style.display = 'inline-flex';
            } else {
                showError('Could not detect geometric patterns in the image');
            }

            document.getElementById('processing').style.display = 'none';
        }

        function updatePhysicsMapping() {
            const patternType = document.getElementById('patternType').value;
            const physicsMap = {
                radial: { symmetry: 0.85, aspect: 1.0, phi: 0.618, fill: 0.5 },
                linear: { symmetry: 0.65, aspect: 3.0, phi: 2.382, fill: 0.3 },
                network: { symmetry: 0.55, aspect: 1.2, phi: 0.8, fill: 0.15 },
                fractal: { symmetry: 0.45, aspect: 1.4, phi: 0.4, fill: 0.7 }
            };
            
            const params = physicsMap[patternType];
            document.getElementById('symmetryScore').value = params.symmetry;
            document.getElementById('aspectRatio').value = params.aspect;
            document.getElementById('phiDeviation').value = params.phi;
            document.getElementById('fillDensity').value = params.fill;
        }

        async function encodeGeometry() {
            document.getElementById('processing').style.display = 'block';
            hideError();

            await new Promise(resolve => setTimeout(resolve, 1500));

            const params = {
                patternType: document.getElementById('patternType').value,
                symmetryScore: parseFloat(document.getElementById('symmetryScore').value),
                aspectRatio: parseFloat(document.getElementById('aspectRatio').value),
                phiDeviation: parseFloat(document.getElementById('phiDeviation').value),
                fillDensity: parseFloat(document.getElementById('fillDensity').value),
                scaleFactor: parseFloat(document.getElementById('scaleFactor').value)
            };

            const geometry = generateGeometry(params);
            if (geometry) {
                displayGeneratedGeometry(geometry);
                const analysis = createAnalysisFromParams(params);
                currentAnalysis = analysis;
                displayResults(analysis);
                document.getElementById('copyEncodeBtn').style.display = 'inline-flex';
            }

            document.getElementById('processing').style.display = 'none';
        }

        function generateGeometry(params) {
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 400, 400);
            ctx.strokeStyle = '#1e40af';
            ctx.lineWidth = 2;
            
            const centerX = 200, centerY = 200, scale = params.scaleFactor;
            
            switch(params.patternType) {
                case 'radial':
                    for(let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const radius = scale * params.symmetryScore;
                        ctx.beginPath();
                        ctx.arc(centerX + Math.cos(angle) * radius/2, centerY + Math.sin(angle) * radius/2, 20, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    break;
                case 'linear':
                    for(let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        ctx.moveTo(50, 100 + i * 50);
                        ctx.lineTo(350, 100 + i * 50 + Math.sin(i) * 20);
                        ctx.stroke();
                    }
                    break;
                case 'network':
                    const gridSize = 40;
                    for(let x = 0; x < 10; x++) {
                        for(let y = 0; y < 10; y++) {
                            ctx.beginPath();
                            ctx.rect(x * gridSize, y * gridSize, gridSize/2, gridSize/2);
                            ctx.stroke();
                        }
                    }
                    break;
                case 'fractal':
                    drawFractal(ctx, centerX, centerY, scale/2, 3);
                    break;
            }
            
            return canvas;
        }

        function drawFractal(ctx, x, y, size, depth) {
            if (depth === 0) return;
            ctx.beginPath();
            ctx.rect(x - size/2, y - size/2, size, size);
            ctx.stroke();
            
            const newSize = size / 3;
            drawFractal(ctx, x - size/3, y - size/3, newSize, depth - 1);
            drawFractal(ctx, x + size/3, y - size/3, newSize, depth - 1);
            drawFractal(ctx, x - size/3, y + size/3, newSize, depth - 1);
            drawFractal(ctx, x + size/3, y + size/3, newSize, depth - 1);
        }

        function analyzeCanvas(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let nonWhitePixels = 0;
            let totalPixels = canvas.width * canvas.height;
            
            for (let i = 0; i < data.length; i += 4) {
                if (data[i] < 240 || data[i+1] < 240 || data[i+2] < 240) {
                    nonWhitePixels++;
                }
            }
            
            const fillDensity = nonWhitePixels / totalPixels;
            const aspectRatio = canvas.width / canvas.height;
            const symmetryScore = Math.random() * 0.3 + 0.6; // Simulate analysis
            const phiDeviation = Math.abs(aspectRatio - 1.618);
            
            return {
                geometricPoints: Math.floor(nonWhitePixels / 100),
                centerCoords: [canvas.width/2, canvas.height/2],
                aspectRatio: aspectRatio,
                phiDeviation: phiDeviation,
                fillDensity: fillDensity,
                patternType: fillDensity > 0.3 ? 'radial' : 'linear',
                symmetryScore: symmetryScore,
                classification: symmetryScore > 0.8 ? 'UNIVERSAL' : 'SPECIFIC',
                equation: fillDensity > 0.5 ? 'âˆ‡Â²Ïˆ + Î»Ïˆ = 0' : 'Ïˆ(x,t) = Asin(kx-Ï‰t)',
                physicsLaw: 'Wave Equation',
                crossDomainFit: symmetryScore * 100
            };
        }

        function createAnalysisFromParams(params) {
            return {
                geometricPoints: Math.floor(params.fillDensity * 1000),
                centerCoords: [200, 200],
                aspectRatio: params.aspectRatio,
                phiDeviation: params.phiDeviation,
                fillDensity: params.fillDensity,
                patternType: params.patternType,
                symmetryScore: params.symmetryScore,
                classification: params.symmetryScore > 0.8 ? 'UNIVERSAL' : 'SPECIFIC',
                equation: params.patternType === 'radial' ? 'âˆ‡Â²Ïˆ + Î»Ïˆ = 0' : 'Ïˆ(x,t) = Asin(kx-Ï‰t)',
                physicsLaw: 'Harmonic Oscillator',
                crossDomainFit: params.symmetryScore * 100
            };
        }

        function displayGeneratedGeometry(canvas) {
            const container = document.getElementById('generatedGeometry');
            container.innerHTML = '';
            container.appendChild(canvas);
            container.style.display = 'block';
        }

        function displayResults(analysis) {
            const results = document.getElementById('results');
            results.innerHTML = `
                <div class="results">
                    <div class="step">
                        <div class="step-title">Step 1: Geometric Feature Extraction</div>
                        <div class="data-grid">
                            <div class="data-item">
                                <div class="data-label">Geometric Points</div>
                                <div class="data-value">${analysis.geometricPoints}</div>
                            </div>
                            <div class="data-item">
                                <div class="data-label">Center Coordinates</div>
                                <div class="data-value">[${analysis.centerCoords[0]}, ${analysis.centerCoords[1]}]</div>
                            </div>
                            <div class="data-item">
                                <div class="data-label">Aspect Ratio</div>
                                <div class="data-value">${analysis.aspectRatio.toFixed(3)}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="step">
                        <div class="step-title">Step 2: Pattern Recognition</div>
                        <div class="data-grid">
                            <div class="data-item">
                                <div class="data-label">Pattern Type</div>
                                <div class="data-value">${analysis.patternType.toUpperCase()}</div>
                            </div>
                            <div class="data-item">
                                <div class="data-label">Symmetry Score</div>
                                <div class="data-value">${analysis.symmetryScore.toFixed(3)}</div>
                            </div>
                            <div class="data-item">
                                <div class="data-label">Fill Density</div>
                                <div class="data-value">${analysis.fillDensity.toFixed(3)}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="step">
                        <div class="step-title">Step 3: Mathematical Mapping</div>
                        <div class="data-grid">
                            <div class="data-item">
                                <div class="data-label">Governing Equation</div>
                                <div class="data-value">${analysis.equation}</div>
                            </div>
                            <div class="data-item">
                                <div class="data-label">Physics Law</div>
                                <div class="data-value">${analysis.physicsLaw}</div>
                            </div>
                            <div class="data-item">
                                <div class="data-label">Golden Ratio Deviation</div>
                                <div class="data-value">${analysis.phiDeviation.toFixed(3)}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="step">
                        <div class="step-title">Step 4: Universality Assessment</div>
                        <div class="data-grid">
                            <div class="data-item">
                                <div class="data-label">Classification</div>
                                <div class="data-value">${analysis.classification}</div>
                            </div>
                            <div class="data-item">
                                <div class="data-label">Cross-Domain Fit</div>
                                <div class="data-value">${analysis.crossDomainFit.toFixed(1)}%</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            results.style.display = 'block';
        }

        function copyResults(mode) {
            if (!currentAnalysis) return;
            
            const text = `Geometric Analysis Results:
Points: ${currentAnalysis.geometricPoints}
Pattern: ${currentAnalysis.patternType}
Symmetry: ${currentAnalysis.symmetryScore.toFixed(3)}
Equation: ${currentAnalysis.equation}
Classification: ${currentAnalysis.classification}`;
            
            navigator.clipboard.writeText(text).then(() => {
                const btn = document.getElementById(mode === 'decode' ? 'copyDecodeBtn' : 'copyEncodeBtn');
                const orig = btn.textContent;
                btn.textContent = 'âœ… Copied!';
                setTimeout(() => btn.textContent = orig, 2000);
            });
        }

        function clearAll() {
            document.getElementById('imagePreview').style.display = 'none';
            document.getElementById('generatedGeometry').style.display = 'none';
            document.getElementById('results').style.display = 'none';
            document.getElementById('processing').style.display = 'none';
            document.getElementById('decodeBtn').disabled = true;
            document.getElementById('copyDecodeBtn').style.display = 'none';
            document.getElementById('copyEncodeBtn').style.display = 'none';
            document.getElementById('fileInput').value = '';
            currentAnalysis = null;
            hideError();
        }

        function showError(message) {
            const error = document.getElementById('error');
            error.textContent = message;
            error.style.display = 'block';
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }
    </script>
</body>
</html>
